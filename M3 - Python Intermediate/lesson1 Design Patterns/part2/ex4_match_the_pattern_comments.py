"""
Exercise 2 — Match the Pattern to the Use Case (fill-in inside Python file)
Instructions:
- Use the PATTERN BANK (A–H) below.
- For each use case (1–8), fill the ANSWERS dict with a list of letters.
- Some use cases have MULTIPLE valid answers.
- Keep answers as strings, e.g., ["E"], ["D", "G"].

PATTERN BANK
A. Singleton
B. Factory Method
C. Adapter
D. Decorator
E. Strategy
F. Observer
G. Proxy
H. Builder

USE CASES
1) A single app-wide telemetry collector should exist—everyone imports and uses the same instance.
2) Choose compression algorithm (gzip, bz2, lzma) at runtime based on data characteristics.
3) Code expects .charge(amount) but Stripe/PayPal SDKs differ; you wrap each to expose a common interface.
4) Add retries and request logging to an HTTP client without editing its code.
5) A “Save” button should trigger autosave, analytics, and a UI toast—each handled separately.
6) Build a complex Report (title, sections, optional charts, appendix) via a fluent API, then .build().
7) Given a config string ("sqlite" / "postgres"), create the proper DatabaseConnection without if/elif scattered around.
8) Images should load lazily and originals blocked for non-subscribers.
"""

# === Your Answers Here ===
# Example format: ANSWERS = {1: ["A"], 2: ["E"], 4: ["D", "G"], ...}
ANSWERS = {
    1: [],
    2: [],
    3: [],
    4: [],  # multiple possible
    5: [],
    6: [],
    7: [],
    8: [],  # multiple possible
}



